import { nextTick, ComputedRef, PropType, Ref, ComponentInternalInstance } from 'vue';
declare type BeforeLeave = (newTabName: string, oldTabName: string) => void | Promise<void> | boolean;
export interface IETabsProps {
    type: string;
    activeName: string;
    closable: boolean;
    addable: boolean;
    modelValue: string;
    editable: boolean;
    tabPosition: string;
    beforeLeave: BeforeLeave;
    stretch: boolean;
}
export interface RootTabs {
    props: IETabsProps;
    currentName: Ref<string>;
}
export interface IEPaneProps {
    label: string;
    name: string;
    closable: boolean;
    disabled: boolean;
    lazy: boolean;
}
export interface Pane {
    uid: number;
    instance: ComponentInternalInstance;
    props: IEPaneProps;
    paneName: ComputedRef<string>;
    active: ComputedRef<boolean>;
    index: Ref<string>;
    isClosable: ComputedRef<boolean>;
}
export declare type UpdatePaneStateCallback = (pane: Pane) => void;
declare const _default: import("vue").DefineComponent<{
    type: {
        type: StringConstructor;
        default: string;
    };
    activeName: {
        type: StringConstructor;
        default: string;
    };
    closable: BooleanConstructor;
    addable: BooleanConstructor;
    modelValue: {
        type: StringConstructor;
        default: string;
    };
    editable: BooleanConstructor;
    tabPosition: {
        type: StringConstructor;
        default: string;
    };
    beforeLeave: {
        type: PropType<BeforeLeave>;
        default: any;
    };
    stretch: BooleanConstructor;
}, {
    nav$: Ref<{
        new (...args: any[]): ({
            $: ComponentInternalInstance;
            $data: {};
            $props: (Partial<{
                [x: number]: string;
            }> & Pick<(Readonly<{
                [x: number]: string;
            } & {
                length?: number;
                toString?: string;
                toLocaleString?: string;
                concat?: string[];
                join?: string;
                slice?: string[];
                indexOf?: (searchElement: string, fromIndex?: number) => number;
                lastIndexOf?: (searchElement: string, fromIndex?: number) => number;
                every?: {
                    <S extends string>(predicate: (value: string, index: number, array: readonly string[]) => value is S, thisArg?: any): this is readonly S[];
                    (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any): boolean;
                };
                some?: (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any) => boolean;
                forEach?: (callbackfn: (value: string, index: number, array: readonly string[]) => void, thisArg?: any) => void;
                map?: <U>(callbackfn: (value: string, index: number, array: readonly string[]) => U, thisArg?: any) => U[];
                filter?: {
                    <S_1 extends string>(predicate: (value: string, index: number, array: readonly string[]) => value is S_1, thisArg?: any): S_1[];
                    (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any): string[];
                };
                reduce?: {
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string): string;
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string, initialValue: string): string;
                    <U_1>(callbackfn: (previousValue: U_1, currentValue: string, currentIndex: number, array: readonly string[]) => U_1, initialValue: U_1): U_1;
                };
                reduceRight?: {
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string): string;
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string, initialValue: string): string;
                    <U_2>(callbackfn: (previousValue: U_2, currentValue: string, currentIndex: number, array: readonly string[]) => U_2, initialValue: U_2): U_2;
                };
                find?: {
                    <S_2 extends string>(predicate: (this: void, value: string, index: number, obj: readonly string[]) => value is S_2, thisArg?: any): S_2;
                    (predicate: (value: string, index: number, obj: readonly string[]) => unknown, thisArg?: any): string;
                };
                findIndex?: (predicate: (value: string, index: number, obj: readonly string[]) => unknown, thisArg?: any) => number;
                entries?: IterableIterator<[number, string]>;
                keys?: IterableIterator<number>;
                values?: IterableIterator<string>;
                includes?: (searchElement: string, fromIndex?: number) => boolean;
                flatMap?: <U_3, This = undefined>(callback: (this: This, value: string, index: number, array: string[]) => U_3 | readonly U_3[], thisArg?: This) => U_3[];
                flat?: unknown[];
            }> & import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps) | (Readonly<{
                [x: number]: string;
            } & {
                length?: number;
                toString?: string;
                toLocaleString?: string;
                concat?: string[];
                join?: string;
                slice?: string[];
                indexOf?: (searchElement: string, fromIndex?: number) => number;
                lastIndexOf?: (searchElement: string, fromIndex?: number) => number;
                every?: {
                    <S extends string>(predicate: (value: string, index: number, array: readonly string[]) => value is S, thisArg?: any): this is readonly S[];
                    (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any): boolean;
                };
                some?: (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any) => boolean;
                forEach?: (callbackfn: (value: string, index: number, array: readonly string[]) => void, thisArg?: any) => void;
                map?: <U>(callbackfn: (value: string, index: number, array: readonly string[]) => U, thisArg?: any) => U[];
                filter?: {
                    <S_1 extends string>(predicate: (value: string, index: number, array: readonly string[]) => value is S_1, thisArg?: any): S_1[];
                    (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any): string[];
                };
                reduce?: {
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string): string;
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string, initialValue: string): string;
                    <U_1>(callbackfn: (previousValue: U_1, currentValue: string, currentIndex: number, array: readonly string[]) => U_1, initialValue: U_1): U_1;
                };
                reduceRight?: {
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string): string;
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string, initialValue: string): string;
                    <U_2>(callbackfn: (previousValue: U_2, currentValue: string, currentIndex: number, array: readonly string[]) => U_2, initialValue: U_2): U_2;
                };
                find?: {
                    <S_2 extends string>(predicate: (this: void, value: string, index: number, obj: readonly string[]) => value is S_2, thisArg?: any): S_2;
                    (predicate: (value: string, index: number, obj: readonly string[]) => unknown, thisArg?: any): string;
                };
                findIndex?: (predicate: (value: string, index: number, obj: readonly string[]) => unknown, thisArg?: any) => number;
                entries?: IterableIterator<[number, string]>;
                keys?: IterableIterator<number>;
                values?: IterableIterator<string>;
                includes?: (searchElement: string, fromIndex?: number) => boolean;
                flatMap?: <U_3, This = undefined>(callback: (this: This, value: string, index: number, array: string[]) => U_3 | readonly U_3[], thisArg?: This) => U_3[];
                flat?: unknown[];
            }> & import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps & Readonly<{} & {
                [x: string]: unknown;
            }>) | (Readonly<{} & {
                [x: string]: unknown;
            }> & import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps & Readonly<{
                [x: number]: string;
            } & {
                length?: number;
                toString?: string;
                toLocaleString?: string;
                concat?: string[];
                join?: string;
                slice?: string[];
                indexOf?: (searchElement: string, fromIndex?: number) => number;
                lastIndexOf?: (searchElement: string, fromIndex?: number) => number;
                every?: {
                    <S extends string>(predicate: (value: string, index: number, array: readonly string[]) => value is S, thisArg?: any): this is readonly S[];
                    (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any): boolean;
                };
                some?: (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any) => boolean;
                forEach?: (callbackfn: (value: string, index: number, array: readonly string[]) => void, thisArg?: any) => void;
                map?: <U>(callbackfn: (value: string, index: number, array: readonly string[]) => U, thisArg?: any) => U[];
                filter?: {
                    <S_1 extends string>(predicate: (value: string, index: number, array: readonly string[]) => value is S_1, thisArg?: any): S_1[];
                    (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any): string[];
                };
                reduce?: {
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string): string;
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string, initialValue: string): string;
                    <U_1>(callbackfn: (previousValue: U_1, currentValue: string, currentIndex: number, array: readonly string[]) => U_1, initialValue: U_1): U_1;
                };
                reduceRight?: {
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string): string;
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string, initialValue: string): string;
                    <U_2>(callbackfn: (previousValue: U_2, currentValue: string, currentIndex: number, array: readonly string[]) => U_2, initialValue: U_2): U_2;
                };
                find?: {
                    <S_2 extends string>(predicate: (this: void, value: string, index: number, obj: readonly string[]) => value is S_2, thisArg?: any): S_2;
                    (predicate: (value: string, index: number, obj: readonly string[]) => unknown, thisArg?: any): string;
                };
                findIndex?: (predicate: (value: string, index: number, obj: readonly string[]) => unknown, thisArg?: any) => number;
                entries?: IterableIterator<[number, string]>;
                keys?: IterableIterator<number>;
                values?: IterableIterator<string>;
                includes?: (searchElement: string, fromIndex?: number) => boolean;
                flatMap?: <U_3, This = undefined>(callback: (this: This, value: string, index: number, array: string[]) => U_3 | readonly U_3[], thisArg?: This) => U_3[];
                flat?: unknown[];
            }>) | (Readonly<{} & {
                [x: string]: unknown;
            }> & import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps), "length" | "toString" | "toLocaleString" | "concat" | "join" | "slice" | "indexOf" | "lastIndexOf" | "every" | "some" | "forEach" | "map" | "filter" | "reduce" | "reduceRight" | "find" | "findIndex" | "entries" | "keys" | "values" | "includes" | "flatMap" | "flat" | "key" | "ref" | "onVnodeBeforeMount" | "onVnodeMounted" | "onVnodeBeforeUpdate" | "onVnodeUpdated" | "onVnodeBeforeUnmount" | "onVnodeUnmounted" | "class" | "style" | ((() => string) & string) | ((() => string) & string) | ({
                (...items: ConcatArray<never>[]): never[];
                (...items: ConcatArray<never>[]): never[];
            } & string) | (((separator?: string) => string) & string) | (((start?: number, end?: number) => never[]) & string) | (((searchElement: never, fromIndex?: number) => number) & string) | (((searchElement: never, fromIndex?: number) => number) & string) | ({
                <S_3 extends never>(predicate: (value: never, index: number, array: readonly never[]) => value is S_3, thisArg?: any): this is readonly S_3[];
                (predicate: (value: never, index: number, array: readonly never[]) => unknown, thisArg?: any): boolean;
            } & string) | (((predicate: (value: never, index: number, array: readonly never[]) => unknown, thisArg?: any) => boolean) & string) | (((callbackfn: (value: never, index: number, array: readonly never[]) => void, thisArg?: any) => void) & string) | ((<U_4>(callbackfn: (value: never, index: number, array: readonly never[]) => U_4, thisArg?: any) => U_4[]) & string) | ({
                <S_4 extends never>(predicate: (value: never, index: number, array: readonly never[]) => value is S_4, thisArg?: any): S_4[];
                (predicate: (value: never, index: number, array: readonly never[]) => unknown, thisArg?: any): never[];
            } & string) | ({
                (callbackfn: (previousValue: never, currentValue: never, currentIndex: number, array: readonly never[]) => never): never;
                (callbackfn: (previousValue: never, currentValue: never, currentIndex: number, array: readonly never[]) => never, initialValue: never): never;
                <U_5>(callbackfn: (previousValue: U_5, currentValue: never, currentIndex: number, array: readonly never[]) => U_5, initialValue: U_5): U_5;
            } & string) | ({
                (callbackfn: (previousValue: never, currentValue: never, currentIndex: number, array: readonly never[]) => never): never;
                (callbackfn: (previousValue: never, currentValue: never, currentIndex: number, array: readonly never[]) => never, initialValue: never): never;
                <U_6>(callbackfn: (previousValue: U_6, currentValue: never, currentIndex: number, array: readonly never[]) => U_6, initialValue: U_6): U_6;
            } & string) | ({
                <S_5 extends never>(predicate: (this: void, value: never, index: number, obj: readonly never[]) => value is S_5, thisArg?: any): S_5;
                (predicate: (value: never, index: number, obj: readonly never[]) => unknown, thisArg?: any): never;
            } & string) | (((predicate: (value: never, index: number, obj: readonly never[]) => unknown, thisArg?: any) => number) & string) | ((() => IterableIterator<[number, never]>) & string) | ((() => IterableIterator<number>) & string) | ((() => IterableIterator<never>) & string) | (((searchElement: never, fromIndex?: number) => boolean) & string) | ((<U_7, This_1 = undefined>(callback: (this: This_1, value: never, index: number, array: never[]) => U_7 | readonly U_7[], thisArg?: This_1) => U_7[]) & string) | ((<A, D extends number = 1>(this: A, depth?: D) => FlatArray<A, D>[]) & string)>) | (Partial<{}> & Pick<(Readonly<{
                [x: number]: string;
            } & {
                length?: number;
                toString?: string;
                toLocaleString?: string;
                concat?: string[];
                join?: string;
                slice?: string[];
                indexOf?: (searchElement: string, fromIndex?: number) => number;
                lastIndexOf?: (searchElement: string, fromIndex?: number) => number;
                every?: {
                    <S extends string>(predicate: (value: string, index: number, array: readonly string[]) => value is S, thisArg?: any): this is readonly S[];
                    (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any): boolean;
                };
                some?: (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any) => boolean;
                forEach?: (callbackfn: (value: string, index: number, array: readonly string[]) => void, thisArg?: any) => void;
                map?: <U>(callbackfn: (value: string, index: number, array: readonly string[]) => U, thisArg?: any) => U[];
                filter?: {
                    <S_1 extends string>(predicate: (value: string, index: number, array: readonly string[]) => value is S_1, thisArg?: any): S_1[];
                    (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any): string[];
                };
                reduce?: {
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string): string;
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string, initialValue: string): string;
                    <U_1>(callbackfn: (previousValue: U_1, currentValue: string, currentIndex: number, array: readonly string[]) => U_1, initialValue: U_1): U_1;
                };
                reduceRight?: {
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string): string;
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string, initialValue: string): string;
                    <U_2>(callbackfn: (previousValue: U_2, currentValue: string, currentIndex: number, array: readonly string[]) => U_2, initialValue: U_2): U_2;
                };
                find?: {
                    <S_2 extends string>(predicate: (this: void, value: string, index: number, obj: readonly string[]) => value is S_2, thisArg?: any): S_2;
                    (predicate: (value: string, index: number, obj: readonly string[]) => unknown, thisArg?: any): string;
                };
                findIndex?: (predicate: (value: string, index: number, obj: readonly string[]) => unknown, thisArg?: any) => number;
                entries?: IterableIterator<[number, string]>;
                keys?: IterableIterator<number>;
                values?: IterableIterator<string>;
                includes?: (searchElement: string, fromIndex?: number) => boolean;
                flatMap?: <U_3, This = undefined>(callback: (this: This, value: string, index: number, array: string[]) => U_3 | readonly U_3[], thisArg?: This) => U_3[];
                flat?: unknown[];
            }> & import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps) | (Readonly<{
                [x: number]: string;
            } & {
                length?: number;
                toString?: string;
                toLocaleString?: string;
                concat?: string[];
                join?: string;
                slice?: string[];
                indexOf?: (searchElement: string, fromIndex?: number) => number;
                lastIndexOf?: (searchElement: string, fromIndex?: number) => number;
                every?: {
                    <S extends string>(predicate: (value: string, index: number, array: readonly string[]) => value is S, thisArg?: any): this is readonly S[];
                    (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any): boolean;
                };
                some?: (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any) => boolean;
                forEach?: (callbackfn: (value: string, index: number, array: readonly string[]) => void, thisArg?: any) => void;
                map?: <U>(callbackfn: (value: string, index: number, array: readonly string[]) => U, thisArg?: any) => U[];
                filter?: {
                    <S_1 extends string>(predicate: (value: string, index: number, array: readonly string[]) => value is S_1, thisArg?: any): S_1[];
                    (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any): string[];
                };
                reduce?: {
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string): string;
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string, initialValue: string): string;
                    <U_1>(callbackfn: (previousValue: U_1, currentValue: string, currentIndex: number, array: readonly string[]) => U_1, initialValue: U_1): U_1;
                };
                reduceRight?: {
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string): string;
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string, initialValue: string): string;
                    <U_2>(callbackfn: (previousValue: U_2, currentValue: string, currentIndex: number, array: readonly string[]) => U_2, initialValue: U_2): U_2;
                };
                find?: {
                    <S_2 extends string>(predicate: (this: void, value: string, index: number, obj: readonly string[]) => value is S_2, thisArg?: any): S_2;
                    (predicate: (value: string, index: number, obj: readonly string[]) => unknown, thisArg?: any): string;
                };
                findIndex?: (predicate: (value: string, index: number, obj: readonly string[]) => unknown, thisArg?: any) => number;
                entries?: IterableIterator<[number, string]>;
                keys?: IterableIterator<number>;
                values?: IterableIterator<string>;
                includes?: (searchElement: string, fromIndex?: number) => boolean;
                flatMap?: <U_3, This = undefined>(callback: (this: This, value: string, index: number, array: string[]) => U_3 | readonly U_3[], thisArg?: This) => U_3[];
                flat?: unknown[];
            }> & import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps & Readonly<{} & {
                [x: string]: unknown;
            }>) | (Readonly<{} & {
                [x: string]: unknown;
            }> & import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps & Readonly<{
                [x: number]: string;
            } & {
                length?: number;
                toString?: string;
                toLocaleString?: string;
                concat?: string[];
                join?: string;
                slice?: string[];
                indexOf?: (searchElement: string, fromIndex?: number) => number;
                lastIndexOf?: (searchElement: string, fromIndex?: number) => number;
                every?: {
                    <S extends string>(predicate: (value: string, index: number, array: readonly string[]) => value is S, thisArg?: any): this is readonly S[];
                    (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any): boolean;
                };
                some?: (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any) => boolean;
                forEach?: (callbackfn: (value: string, index: number, array: readonly string[]) => void, thisArg?: any) => void;
                map?: <U>(callbackfn: (value: string, index: number, array: readonly string[]) => U, thisArg?: any) => U[];
                filter?: {
                    <S_1 extends string>(predicate: (value: string, index: number, array: readonly string[]) => value is S_1, thisArg?: any): S_1[];
                    (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any): string[];
                };
                reduce?: {
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string): string;
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string, initialValue: string): string;
                    <U_1>(callbackfn: (previousValue: U_1, currentValue: string, currentIndex: number, array: readonly string[]) => U_1, initialValue: U_1): U_1;
                };
                reduceRight?: {
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string): string;
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string, initialValue: string): string;
                    <U_2>(callbackfn: (previousValue: U_2, currentValue: string, currentIndex: number, array: readonly string[]) => U_2, initialValue: U_2): U_2;
                };
                find?: {
                    <S_2 extends string>(predicate: (this: void, value: string, index: number, obj: readonly string[]) => value is S_2, thisArg?: any): S_2;
                    (predicate: (value: string, index: number, obj: readonly string[]) => unknown, thisArg?: any): string;
                };
                findIndex?: (predicate: (value: string, index: number, obj: readonly string[]) => unknown, thisArg?: any) => number;
                entries?: IterableIterator<[number, string]>;
                keys?: IterableIterator<number>;
                values?: IterableIterator<string>;
                includes?: (searchElement: string, fromIndex?: number) => boolean;
                flatMap?: <U_3, This = undefined>(callback: (this: This, value: string, index: number, array: string[]) => U_3 | readonly U_3[], thisArg?: This) => U_3[];
                flat?: unknown[];
            }>) | (Readonly<{} & {
                [x: string]: unknown;
            }> & import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps), "length" | "toString" | "toLocaleString" | "concat" | "join" | "slice" | "indexOf" | "lastIndexOf" | "every" | "some" | "forEach" | "map" | "filter" | "reduce" | "reduceRight" | "find" | "findIndex" | "entries" | "keys" | "values" | "includes" | "flatMap" | "flat" | "key" | "ref" | "onVnodeBeforeMount" | "onVnodeMounted" | "onVnodeBeforeUpdate" | "onVnodeUpdated" | "onVnodeBeforeUnmount" | "onVnodeUnmounted" | "class" | "style" | ((() => string) & string) | ((() => string) & string) | ({
                (...items: ConcatArray<never>[]): never[];
                (...items: ConcatArray<never>[]): never[];
            } & string) | (((separator?: string) => string) & string) | (((start?: number, end?: number) => never[]) & string) | (((searchElement: never, fromIndex?: number) => number) & string) | (((searchElement: never, fromIndex?: number) => number) & string) | ({
                <S_3 extends never>(predicate: (value: never, index: number, array: readonly never[]) => value is S_3, thisArg?: any): this is readonly S_3[];
                (predicate: (value: never, index: number, array: readonly never[]) => unknown, thisArg?: any): boolean;
            } & string) | (((predicate: (value: never, index: number, array: readonly never[]) => unknown, thisArg?: any) => boolean) & string) | (((callbackfn: (value: never, index: number, array: readonly never[]) => void, thisArg?: any) => void) & string) | ((<U_4>(callbackfn: (value: never, index: number, array: readonly never[]) => U_4, thisArg?: any) => U_4[]) & string) | ({
                <S_4 extends never>(predicate: (value: never, index: number, array: readonly never[]) => value is S_4, thisArg?: any): S_4[];
                (predicate: (value: never, index: number, array: readonly never[]) => unknown, thisArg?: any): never[];
            } & string) | ({
                (callbackfn: (previousValue: never, currentValue: never, currentIndex: number, array: readonly never[]) => never): never;
                (callbackfn: (previousValue: never, currentValue: never, currentIndex: number, array: readonly never[]) => never, initialValue: never): never;
                <U_5>(callbackfn: (previousValue: U_5, currentValue: never, currentIndex: number, array: readonly never[]) => U_5, initialValue: U_5): U_5;
            } & string) | ({
                (callbackfn: (previousValue: never, currentValue: never, currentIndex: number, array: readonly never[]) => never): never;
                (callbackfn: (previousValue: never, currentValue: never, currentIndex: number, array: readonly never[]) => never, initialValue: never): never;
                <U_6>(callbackfn: (previousValue: U_6, currentValue: never, currentIndex: number, array: readonly never[]) => U_6, initialValue: U_6): U_6;
            } & string) | ({
                <S_5 extends never>(predicate: (this: void, value: never, index: number, obj: readonly never[]) => value is S_5, thisArg?: any): S_5;
                (predicate: (value: never, index: number, obj: readonly never[]) => unknown, thisArg?: any): never;
            } & string) | (((predicate: (value: never, index: number, obj: readonly never[]) => unknown, thisArg?: any) => number) & string) | ((() => IterableIterator<[number, never]>) & string) | ((() => IterableIterator<number>) & string) | ((() => IterableIterator<never>) & string) | (((searchElement: never, fromIndex?: number) => boolean) & string) | ((<U_7, This_1 = undefined>(callback: (this: This_1, value: never, index: number, array: never[]) => U_7 | readonly U_7[], thisArg?: This_1) => U_7[]) & string) | ((<A, D extends number = 1>(this: A, depth?: D) => FlatArray<A, D>[]) & string)>);
            $attrs: Record<string, unknown>;
            $refs: Record<string, unknown>;
            $slots: Readonly<{
                [name: string]: import("vue").Slot;
            }>;
            $root: import("vue").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("vue").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}>>;
            $parent: import("vue").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("vue").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}>>;
            $emit: ((event: string, ...args: any[]) => void) | ((event: string, ...args: any[]) => void);
            $el: any;
            $options: import("vue").ComponentOptionsBase<Readonly<{
                [x: number]: string;
            } & {
                length?: number;
                toString?: string;
                toLocaleString?: string;
                concat?: string[];
                join?: string;
                slice?: string[];
                indexOf?: (searchElement: string, fromIndex?: number) => number;
                lastIndexOf?: (searchElement: string, fromIndex?: number) => number;
                every?: {
                    <S extends string>(predicate: (value: string, index: number, array: readonly string[]) => value is S, thisArg?: any): this is readonly S[];
                    (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any): boolean;
                };
                some?: (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any) => boolean;
                forEach?: (callbackfn: (value: string, index: number, array: readonly string[]) => void, thisArg?: any) => void;
                map?: <U>(callbackfn: (value: string, index: number, array: readonly string[]) => U, thisArg?: any) => U[];
                filter?: {
                    <S_1 extends string>(predicate: (value: string, index: number, array: readonly string[]) => value is S_1, thisArg?: any): S_1[];
                    (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any): string[];
                };
                reduce?: {
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string): string;
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string, initialValue: string): string;
                    <U_1>(callbackfn: (previousValue: U_1, currentValue: string, currentIndex: number, array: readonly string[]) => U_1, initialValue: U_1): U_1;
                };
                reduceRight?: {
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string): string;
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string, initialValue: string): string;
                    <U_2>(callbackfn: (previousValue: U_2, currentValue: string, currentIndex: number, array: readonly string[]) => U_2, initialValue: U_2): U_2;
                };
                find?: {
                    <S_2 extends string>(predicate: (this: void, value: string, index: number, obj: readonly string[]) => value is S_2, thisArg?: any): S_2;
                    (predicate: (value: string, index: number, obj: readonly string[]) => unknown, thisArg?: any): string;
                };
                findIndex?: (predicate: (value: string, index: number, obj: readonly string[]) => unknown, thisArg?: any) => number;
                entries?: IterableIterator<[number, string]>;
                keys?: IterableIterator<number>;
                values?: IterableIterator<string>;
                includes?: (searchElement: string, fromIndex?: number) => boolean;
                flatMap?: <U_3, This = undefined>(callback: (this: This, value: string, index: number, array: string[]) => U_3 | readonly U_3[], thisArg?: This) => U_3[];
                flat?: unknown[];
            }> | Readonly<{} & {
                [x: string]: unknown;
            }>, unknown, unknown, Record<string, import("@vue/reactivity").ComputedGetter<any> | import("vue").WritableComputedOptions<any>>, import("vue").MethodOptions, import("vue").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, any>, import("vue").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, any>, import("vue").EmitsOptions, string, {
                [x: number]: string;
            } | {}>;
            $forceUpdate: import("vue").ReactiveEffect<any>;
            $nextTick: typeof nextTick;
            $watch(source: string | Function, cb: Function, options?: import("vue").WatchOptions<boolean>): import("vue").WatchStopHandle;
        } & Readonly<{
            [x: number]: string;
        } & {
            length?: number;
            toString?: string;
            toLocaleString?: string;
            concat?: string[];
            join?: string;
            slice?: string[];
            indexOf?: (searchElement: string, fromIndex?: number) => number;
            lastIndexOf?: (searchElement: string, fromIndex?: number) => number;
            every?: {
                <S extends string>(predicate: (value: string, index: number, array: readonly string[]) => value is S, thisArg?: any): this is readonly S[];
                (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any): boolean;
            };
            some?: (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any) => boolean;
            forEach?: (callbackfn: (value: string, index: number, array: readonly string[]) => void, thisArg?: any) => void;
            map?: <U>(callbackfn: (value: string, index: number, array: readonly string[]) => U, thisArg?: any) => U[];
            filter?: {
                <S_1 extends string>(predicate: (value: string, index: number, array: readonly string[]) => value is S_1, thisArg?: any): S_1[];
                (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any): string[];
            };
            reduce?: {
                (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string): string;
                (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string, initialValue: string): string;
                <U_1>(callbackfn: (previousValue: U_1, currentValue: string, currentIndex: number, array: readonly string[]) => U_1, initialValue: U_1): U_1;
            };
            reduceRight?: {
                (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string): string;
                (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string, initialValue: string): string;
                <U_2>(callbackfn: (previousValue: U_2, currentValue: string, currentIndex: number, array: readonly string[]) => U_2, initialValue: U_2): U_2;
            };
            find?: {
                <S_2 extends string>(predicate: (this: void, value: string, index: number, obj: readonly string[]) => value is S_2, thisArg?: any): S_2;
                (predicate: (value: string, index: number, obj: readonly string[]) => unknown, thisArg?: any): string;
            };
            findIndex?: (predicate: (value: string, index: number, obj: readonly string[]) => unknown, thisArg?: any) => number;
            entries?: IterableIterator<[number, string]>;
            keys?: IterableIterator<number>;
            values?: IterableIterator<string>;
            includes?: (searchElement: string, fromIndex?: number) => boolean;
            flatMap?: <U_3, This = undefined>(callback: (this: This, value: string, index: number, array: string[]) => U_3 | readonly U_3[], thisArg?: This) => U_3[];
            flat?: unknown[];
        }> & import("vue").ShallowUnwrapRef<{}> & {
            [x: string]: never;
        } & import("vue").MethodOptions & import("vue").ComponentCustomProperties) | ({
            $: ComponentInternalInstance;
            $data: {};
            $props: (Partial<{
                [x: number]: string;
            }> & Pick<(Readonly<{
                [x: number]: string;
            } & {
                length?: number;
                toString?: string;
                toLocaleString?: string;
                concat?: string[];
                join?: string;
                slice?: string[];
                indexOf?: (searchElement: string, fromIndex?: number) => number;
                lastIndexOf?: (searchElement: string, fromIndex?: number) => number;
                every?: {
                    <S extends string>(predicate: (value: string, index: number, array: readonly string[]) => value is S, thisArg?: any): this is readonly S[];
                    (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any): boolean;
                };
                some?: (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any) => boolean;
                forEach?: (callbackfn: (value: string, index: number, array: readonly string[]) => void, thisArg?: any) => void;
                map?: <U>(callbackfn: (value: string, index: number, array: readonly string[]) => U, thisArg?: any) => U[];
                filter?: {
                    <S_1 extends string>(predicate: (value: string, index: number, array: readonly string[]) => value is S_1, thisArg?: any): S_1[];
                    (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any): string[];
                };
                reduce?: {
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string): string;
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string, initialValue: string): string;
                    <U_1>(callbackfn: (previousValue: U_1, currentValue: string, currentIndex: number, array: readonly string[]) => U_1, initialValue: U_1): U_1;
                };
                reduceRight?: {
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string): string;
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string, initialValue: string): string;
                    <U_2>(callbackfn: (previousValue: U_2, currentValue: string, currentIndex: number, array: readonly string[]) => U_2, initialValue: U_2): U_2;
                };
                find?: {
                    <S_2 extends string>(predicate: (this: void, value: string, index: number, obj: readonly string[]) => value is S_2, thisArg?: any): S_2;
                    (predicate: (value: string, index: number, obj: readonly string[]) => unknown, thisArg?: any): string;
                };
                findIndex?: (predicate: (value: string, index: number, obj: readonly string[]) => unknown, thisArg?: any) => number;
                entries?: IterableIterator<[number, string]>;
                keys?: IterableIterator<number>;
                values?: IterableIterator<string>;
                includes?: (searchElement: string, fromIndex?: number) => boolean;
                flatMap?: <U_3, This = undefined>(callback: (this: This, value: string, index: number, array: string[]) => U_3 | readonly U_3[], thisArg?: This) => U_3[];
                flat?: unknown[];
            }> & import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps) | (Readonly<{
                [x: number]: string;
            } & {
                length?: number;
                toString?: string;
                toLocaleString?: string;
                concat?: string[];
                join?: string;
                slice?: string[];
                indexOf?: (searchElement: string, fromIndex?: number) => number;
                lastIndexOf?: (searchElement: string, fromIndex?: number) => number;
                every?: {
                    <S extends string>(predicate: (value: string, index: number, array: readonly string[]) => value is S, thisArg?: any): this is readonly S[];
                    (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any): boolean;
                };
                some?: (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any) => boolean;
                forEach?: (callbackfn: (value: string, index: number, array: readonly string[]) => void, thisArg?: any) => void;
                map?: <U>(callbackfn: (value: string, index: number, array: readonly string[]) => U, thisArg?: any) => U[];
                filter?: {
                    <S_1 extends string>(predicate: (value: string, index: number, array: readonly string[]) => value is S_1, thisArg?: any): S_1[];
                    (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any): string[];
                };
                reduce?: {
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string): string;
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string, initialValue: string): string;
                    <U_1>(callbackfn: (previousValue: U_1, currentValue: string, currentIndex: number, array: readonly string[]) => U_1, initialValue: U_1): U_1;
                };
                reduceRight?: {
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string): string;
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string, initialValue: string): string;
                    <U_2>(callbackfn: (previousValue: U_2, currentValue: string, currentIndex: number, array: readonly string[]) => U_2, initialValue: U_2): U_2;
                };
                find?: {
                    <S_2 extends string>(predicate: (this: void, value: string, index: number, obj: readonly string[]) => value is S_2, thisArg?: any): S_2;
                    (predicate: (value: string, index: number, obj: readonly string[]) => unknown, thisArg?: any): string;
                };
                findIndex?: (predicate: (value: string, index: number, obj: readonly string[]) => unknown, thisArg?: any) => number;
                entries?: IterableIterator<[number, string]>;
                keys?: IterableIterator<number>;
                values?: IterableIterator<string>;
                includes?: (searchElement: string, fromIndex?: number) => boolean;
                flatMap?: <U_3, This = undefined>(callback: (this: This, value: string, index: number, array: string[]) => U_3 | readonly U_3[], thisArg?: This) => U_3[];
                flat?: unknown[];
            }> & import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps & Readonly<{} & {
                [x: string]: unknown;
            }>) | (Readonly<{} & {
                [x: string]: unknown;
            }> & import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps & Readonly<{
                [x: number]: string;
            } & {
                length?: number;
                toString?: string;
                toLocaleString?: string;
                concat?: string[];
                join?: string;
                slice?: string[];
                indexOf?: (searchElement: string, fromIndex?: number) => number;
                lastIndexOf?: (searchElement: string, fromIndex?: number) => number;
                every?: {
                    <S extends string>(predicate: (value: string, index: number, array: readonly string[]) => value is S, thisArg?: any): this is readonly S[];
                    (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any): boolean;
                };
                some?: (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any) => boolean;
                forEach?: (callbackfn: (value: string, index: number, array: readonly string[]) => void, thisArg?: any) => void;
                map?: <U>(callbackfn: (value: string, index: number, array: readonly string[]) => U, thisArg?: any) => U[];
                filter?: {
                    <S_1 extends string>(predicate: (value: string, index: number, array: readonly string[]) => value is S_1, thisArg?: any): S_1[];
                    (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any): string[];
                };
                reduce?: {
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string): string;
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string, initialValue: string): string;
                    <U_1>(callbackfn: (previousValue: U_1, currentValue: string, currentIndex: number, array: readonly string[]) => U_1, initialValue: U_1): U_1;
                };
                reduceRight?: {
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string): string;
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string, initialValue: string): string;
                    <U_2>(callbackfn: (previousValue: U_2, currentValue: string, currentIndex: number, array: readonly string[]) => U_2, initialValue: U_2): U_2;
                };
                find?: {
                    <S_2 extends string>(predicate: (this: void, value: string, index: number, obj: readonly string[]) => value is S_2, thisArg?: any): S_2;
                    (predicate: (value: string, index: number, obj: readonly string[]) => unknown, thisArg?: any): string;
                };
                findIndex?: (predicate: (value: string, index: number, obj: readonly string[]) => unknown, thisArg?: any) => number;
                entries?: IterableIterator<[number, string]>;
                keys?: IterableIterator<number>;
                values?: IterableIterator<string>;
                includes?: (searchElement: string, fromIndex?: number) => boolean;
                flatMap?: <U_3, This = undefined>(callback: (this: This, value: string, index: number, array: string[]) => U_3 | readonly U_3[], thisArg?: This) => U_3[];
                flat?: unknown[];
            }>) | (Readonly<{} & {
                [x: string]: unknown;
            }> & import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps), "length" | "toString" | "toLocaleString" | "concat" | "join" | "slice" | "indexOf" | "lastIndexOf" | "every" | "some" | "forEach" | "map" | "filter" | "reduce" | "reduceRight" | "find" | "findIndex" | "entries" | "keys" | "values" | "includes" | "flatMap" | "flat" | "key" | "ref" | "onVnodeBeforeMount" | "onVnodeMounted" | "onVnodeBeforeUpdate" | "onVnodeUpdated" | "onVnodeBeforeUnmount" | "onVnodeUnmounted" | "class" | "style" | ((() => string) & string) | ((() => string) & string) | ({
                (...items: ConcatArray<never>[]): never[];
                (...items: ConcatArray<never>[]): never[];
            } & string) | (((separator?: string) => string) & string) | (((start?: number, end?: number) => never[]) & string) | (((searchElement: never, fromIndex?: number) => number) & string) | (((searchElement: never, fromIndex?: number) => number) & string) | ({
                <S_3 extends never>(predicate: (value: never, index: number, array: readonly never[]) => value is S_3, thisArg?: any): this is readonly S_3[];
                (predicate: (value: never, index: number, array: readonly never[]) => unknown, thisArg?: any): boolean;
            } & string) | (((predicate: (value: never, index: number, array: readonly never[]) => unknown, thisArg?: any) => boolean) & string) | (((callbackfn: (value: never, index: number, array: readonly never[]) => void, thisArg?: any) => void) & string) | ((<U_4>(callbackfn: (value: never, index: number, array: readonly never[]) => U_4, thisArg?: any) => U_4[]) & string) | ({
                <S_4 extends never>(predicate: (value: never, index: number, array: readonly never[]) => value is S_4, thisArg?: any): S_4[];
                (predicate: (value: never, index: number, array: readonly never[]) => unknown, thisArg?: any): never[];
            } & string) | ({
                (callbackfn: (previousValue: never, currentValue: never, currentIndex: number, array: readonly never[]) => never): never;
                (callbackfn: (previousValue: never, currentValue: never, currentIndex: number, array: readonly never[]) => never, initialValue: never): never;
                <U_5>(callbackfn: (previousValue: U_5, currentValue: never, currentIndex: number, array: readonly never[]) => U_5, initialValue: U_5): U_5;
            } & string) | ({
                (callbackfn: (previousValue: never, currentValue: never, currentIndex: number, array: readonly never[]) => never): never;
                (callbackfn: (previousValue: never, currentValue: never, currentIndex: number, array: readonly never[]) => never, initialValue: never): never;
                <U_6>(callbackfn: (previousValue: U_6, currentValue: never, currentIndex: number, array: readonly never[]) => U_6, initialValue: U_6): U_6;
            } & string) | ({
                <S_5 extends never>(predicate: (this: void, value: never, index: number, obj: readonly never[]) => value is S_5, thisArg?: any): S_5;
                (predicate: (value: never, index: number, obj: readonly never[]) => unknown, thisArg?: any): never;
            } & string) | (((predicate: (value: never, index: number, obj: readonly never[]) => unknown, thisArg?: any) => number) & string) | ((() => IterableIterator<[number, never]>) & string) | ((() => IterableIterator<number>) & string) | ((() => IterableIterator<never>) & string) | (((searchElement: never, fromIndex?: number) => boolean) & string) | ((<U_7, This_1 = undefined>(callback: (this: This_1, value: never, index: number, array: never[]) => U_7 | readonly U_7[], thisArg?: This_1) => U_7[]) & string) | ((<A, D extends number = 1>(this: A, depth?: D) => FlatArray<A, D>[]) & string)>) | (Partial<{}> & Pick<(Readonly<{
                [x: number]: string;
            } & {
                length?: number;
                toString?: string;
                toLocaleString?: string;
                concat?: string[];
                join?: string;
                slice?: string[];
                indexOf?: (searchElement: string, fromIndex?: number) => number;
                lastIndexOf?: (searchElement: string, fromIndex?: number) => number;
                every?: {
                    <S extends string>(predicate: (value: string, index: number, array: readonly string[]) => value is S, thisArg?: any): this is readonly S[];
                    (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any): boolean;
                };
                some?: (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any) => boolean;
                forEach?: (callbackfn: (value: string, index: number, array: readonly string[]) => void, thisArg?: any) => void;
                map?: <U>(callbackfn: (value: string, index: number, array: readonly string[]) => U, thisArg?: any) => U[];
                filter?: {
                    <S_1 extends string>(predicate: (value: string, index: number, array: readonly string[]) => value is S_1, thisArg?: any): S_1[];
                    (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any): string[];
                };
                reduce?: {
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string): string;
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string, initialValue: string): string;
                    <U_1>(callbackfn: (previousValue: U_1, currentValue: string, currentIndex: number, array: readonly string[]) => U_1, initialValue: U_1): U_1;
                };
                reduceRight?: {
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string): string;
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string, initialValue: string): string;
                    <U_2>(callbackfn: (previousValue: U_2, currentValue: string, currentIndex: number, array: readonly string[]) => U_2, initialValue: U_2): U_2;
                };
                find?: {
                    <S_2 extends string>(predicate: (this: void, value: string, index: number, obj: readonly string[]) => value is S_2, thisArg?: any): S_2;
                    (predicate: (value: string, index: number, obj: readonly string[]) => unknown, thisArg?: any): string;
                };
                findIndex?: (predicate: (value: string, index: number, obj: readonly string[]) => unknown, thisArg?: any) => number;
                entries?: IterableIterator<[number, string]>;
                keys?: IterableIterator<number>;
                values?: IterableIterator<string>;
                includes?: (searchElement: string, fromIndex?: number) => boolean;
                flatMap?: <U_3, This = undefined>(callback: (this: This, value: string, index: number, array: string[]) => U_3 | readonly U_3[], thisArg?: This) => U_3[];
                flat?: unknown[];
            }> & import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps) | (Readonly<{
                [x: number]: string;
            } & {
                length?: number;
                toString?: string;
                toLocaleString?: string;
                concat?: string[];
                join?: string;
                slice?: string[];
                indexOf?: (searchElement: string, fromIndex?: number) => number;
                lastIndexOf?: (searchElement: string, fromIndex?: number) => number;
                every?: {
                    <S extends string>(predicate: (value: string, index: number, array: readonly string[]) => value is S, thisArg?: any): this is readonly S[];
                    (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any): boolean;
                };
                some?: (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any) => boolean;
                forEach?: (callbackfn: (value: string, index: number, array: readonly string[]) => void, thisArg?: any) => void;
                map?: <U>(callbackfn: (value: string, index: number, array: readonly string[]) => U, thisArg?: any) => U[];
                filter?: {
                    <S_1 extends string>(predicate: (value: string, index: number, array: readonly string[]) => value is S_1, thisArg?: any): S_1[];
                    (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any): string[];
                };
                reduce?: {
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string): string;
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string, initialValue: string): string;
                    <U_1>(callbackfn: (previousValue: U_1, currentValue: string, currentIndex: number, array: readonly string[]) => U_1, initialValue: U_1): U_1;
                };
                reduceRight?: {
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string): string;
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string, initialValue: string): string;
                    <U_2>(callbackfn: (previousValue: U_2, currentValue: string, currentIndex: number, array: readonly string[]) => U_2, initialValue: U_2): U_2;
                };
                find?: {
                    <S_2 extends string>(predicate: (this: void, value: string, index: number, obj: readonly string[]) => value is S_2, thisArg?: any): S_2;
                    (predicate: (value: string, index: number, obj: readonly string[]) => unknown, thisArg?: any): string;
                };
                findIndex?: (predicate: (value: string, index: number, obj: readonly string[]) => unknown, thisArg?: any) => number;
                entries?: IterableIterator<[number, string]>;
                keys?: IterableIterator<number>;
                values?: IterableIterator<string>;
                includes?: (searchElement: string, fromIndex?: number) => boolean;
                flatMap?: <U_3, This = undefined>(callback: (this: This, value: string, index: number, array: string[]) => U_3 | readonly U_3[], thisArg?: This) => U_3[];
                flat?: unknown[];
            }> & import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps & Readonly<{} & {
                [x: string]: unknown;
            }>) | (Readonly<{} & {
                [x: string]: unknown;
            }> & import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps & Readonly<{
                [x: number]: string;
            } & {
                length?: number;
                toString?: string;
                toLocaleString?: string;
                concat?: string[];
                join?: string;
                slice?: string[];
                indexOf?: (searchElement: string, fromIndex?: number) => number;
                lastIndexOf?: (searchElement: string, fromIndex?: number) => number;
                every?: {
                    <S extends string>(predicate: (value: string, index: number, array: readonly string[]) => value is S, thisArg?: any): this is readonly S[];
                    (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any): boolean;
                };
                some?: (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any) => boolean;
                forEach?: (callbackfn: (value: string, index: number, array: readonly string[]) => void, thisArg?: any) => void;
                map?: <U>(callbackfn: (value: string, index: number, array: readonly string[]) => U, thisArg?: any) => U[];
                filter?: {
                    <S_1 extends string>(predicate: (value: string, index: number, array: readonly string[]) => value is S_1, thisArg?: any): S_1[];
                    (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any): string[];
                };
                reduce?: {
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string): string;
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string, initialValue: string): string;
                    <U_1>(callbackfn: (previousValue: U_1, currentValue: string, currentIndex: number, array: readonly string[]) => U_1, initialValue: U_1): U_1;
                };
                reduceRight?: {
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string): string;
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string, initialValue: string): string;
                    <U_2>(callbackfn: (previousValue: U_2, currentValue: string, currentIndex: number, array: readonly string[]) => U_2, initialValue: U_2): U_2;
                };
                find?: {
                    <S_2 extends string>(predicate: (this: void, value: string, index: number, obj: readonly string[]) => value is S_2, thisArg?: any): S_2;
                    (predicate: (value: string, index: number, obj: readonly string[]) => unknown, thisArg?: any): string;
                };
                findIndex?: (predicate: (value: string, index: number, obj: readonly string[]) => unknown, thisArg?: any) => number;
                entries?: IterableIterator<[number, string]>;
                keys?: IterableIterator<number>;
                values?: IterableIterator<string>;
                includes?: (searchElement: string, fromIndex?: number) => boolean;
                flatMap?: <U_3, This = undefined>(callback: (this: This, value: string, index: number, array: string[]) => U_3 | readonly U_3[], thisArg?: This) => U_3[];
                flat?: unknown[];
            }>) | (Readonly<{} & {
                [x: string]: unknown;
            }> & import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps), "length" | "toString" | "toLocaleString" | "concat" | "join" | "slice" | "indexOf" | "lastIndexOf" | "every" | "some" | "forEach" | "map" | "filter" | "reduce" | "reduceRight" | "find" | "findIndex" | "entries" | "keys" | "values" | "includes" | "flatMap" | "flat" | "key" | "ref" | "onVnodeBeforeMount" | "onVnodeMounted" | "onVnodeBeforeUpdate" | "onVnodeUpdated" | "onVnodeBeforeUnmount" | "onVnodeUnmounted" | "class" | "style" | ((() => string) & string) | ((() => string) & string) | ({
                (...items: ConcatArray<never>[]): never[];
                (...items: ConcatArray<never>[]): never[];
            } & string) | (((separator?: string) => string) & string) | (((start?: number, end?: number) => never[]) & string) | (((searchElement: never, fromIndex?: number) => number) & string) | (((searchElement: never, fromIndex?: number) => number) & string) | ({
                <S_3 extends never>(predicate: (value: never, index: number, array: readonly never[]) => value is S_3, thisArg?: any): this is readonly S_3[];
                (predicate: (value: never, index: number, array: readonly never[]) => unknown, thisArg?: any): boolean;
            } & string) | (((predicate: (value: never, index: number, array: readonly never[]) => unknown, thisArg?: any) => boolean) & string) | (((callbackfn: (value: never, index: number, array: readonly never[]) => void, thisArg?: any) => void) & string) | ((<U_4>(callbackfn: (value: never, index: number, array: readonly never[]) => U_4, thisArg?: any) => U_4[]) & string) | ({
                <S_4 extends never>(predicate: (value: never, index: number, array: readonly never[]) => value is S_4, thisArg?: any): S_4[];
                (predicate: (value: never, index: number, array: readonly never[]) => unknown, thisArg?: any): never[];
            } & string) | ({
                (callbackfn: (previousValue: never, currentValue: never, currentIndex: number, array: readonly never[]) => never): never;
                (callbackfn: (previousValue: never, currentValue: never, currentIndex: number, array: readonly never[]) => never, initialValue: never): never;
                <U_5>(callbackfn: (previousValue: U_5, currentValue: never, currentIndex: number, array: readonly never[]) => U_5, initialValue: U_5): U_5;
            } & string) | ({
                (callbackfn: (previousValue: never, currentValue: never, currentIndex: number, array: readonly never[]) => never): never;
                (callbackfn: (previousValue: never, currentValue: never, currentIndex: number, array: readonly never[]) => never, initialValue: never): never;
                <U_6>(callbackfn: (previousValue: U_6, currentValue: never, currentIndex: number, array: readonly never[]) => U_6, initialValue: U_6): U_6;
            } & string) | ({
                <S_5 extends never>(predicate: (this: void, value: never, index: number, obj: readonly never[]) => value is S_5, thisArg?: any): S_5;
                (predicate: (value: never, index: number, obj: readonly never[]) => unknown, thisArg?: any): never;
            } & string) | (((predicate: (value: never, index: number, obj: readonly never[]) => unknown, thisArg?: any) => number) & string) | ((() => IterableIterator<[number, never]>) & string) | ((() => IterableIterator<number>) & string) | ((() => IterableIterator<never>) & string) | (((searchElement: never, fromIndex?: number) => boolean) & string) | ((<U_7, This_1 = undefined>(callback: (this: This_1, value: never, index: number, array: never[]) => U_7 | readonly U_7[], thisArg?: This_1) => U_7[]) & string) | ((<A, D extends number = 1>(this: A, depth?: D) => FlatArray<A, D>[]) & string)>);
            $attrs: Record<string, unknown>;
            $refs: Record<string, unknown>;
            $slots: Readonly<{
                [name: string]: import("vue").Slot;
            }>;
            $root: import("vue").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("vue").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}>>;
            $parent: import("vue").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("vue").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}>>;
            $emit: ((event: string, ...args: any[]) => void) | ((event: string, ...args: any[]) => void);
            $el: any;
            $options: import("vue").ComponentOptionsBase<Readonly<{
                [x: number]: string;
            } & {
                length?: number;
                toString?: string;
                toLocaleString?: string;
                concat?: string[];
                join?: string;
                slice?: string[];
                indexOf?: (searchElement: string, fromIndex?: number) => number;
                lastIndexOf?: (searchElement: string, fromIndex?: number) => number;
                every?: {
                    <S extends string>(predicate: (value: string, index: number, array: readonly string[]) => value is S, thisArg?: any): this is readonly S[];
                    (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any): boolean;
                };
                some?: (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any) => boolean;
                forEach?: (callbackfn: (value: string, index: number, array: readonly string[]) => void, thisArg?: any) => void;
                map?: <U>(callbackfn: (value: string, index: number, array: readonly string[]) => U, thisArg?: any) => U[];
                filter?: {
                    <S_1 extends string>(predicate: (value: string, index: number, array: readonly string[]) => value is S_1, thisArg?: any): S_1[];
                    (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any): string[];
                };
                reduce?: {
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string): string;
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string, initialValue: string): string;
                    <U_1>(callbackfn: (previousValue: U_1, currentValue: string, currentIndex: number, array: readonly string[]) => U_1, initialValue: U_1): U_1;
                };
                reduceRight?: {
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string): string;
                    (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string, initialValue: string): string;
                    <U_2>(callbackfn: (previousValue: U_2, currentValue: string, currentIndex: number, array: readonly string[]) => U_2, initialValue: U_2): U_2;
                };
                find?: {
                    <S_2 extends string>(predicate: (this: void, value: string, index: number, obj: readonly string[]) => value is S_2, thisArg?: any): S_2;
                    (predicate: (value: string, index: number, obj: readonly string[]) => unknown, thisArg?: any): string;
                };
                findIndex?: (predicate: (value: string, index: number, obj: readonly string[]) => unknown, thisArg?: any) => number;
                entries?: IterableIterator<[number, string]>;
                keys?: IterableIterator<number>;
                values?: IterableIterator<string>;
                includes?: (searchElement: string, fromIndex?: number) => boolean;
                flatMap?: <U_3, This = undefined>(callback: (this: This, value: string, index: number, array: string[]) => U_3 | readonly U_3[], thisArg?: This) => U_3[];
                flat?: unknown[];
            }> | Readonly<{} & {
                [x: string]: unknown;
            }>, unknown, unknown, Record<string, import("@vue/reactivity").ComputedGetter<any> | import("vue").WritableComputedOptions<any>>, import("vue").MethodOptions, import("vue").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, any>, import("vue").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, any>, import("vue").EmitsOptions, string, {
                [x: number]: string;
            } | {}>;
            $forceUpdate: import("vue").ReactiveEffect<any>;
            $nextTick: typeof nextTick;
            $watch(source: string | Function, cb: Function, options?: import("vue").WatchOptions<boolean>): import("vue").WatchStopHandle;
        } & Readonly<{} & {
            [x: string]: unknown;
        }> & import("vue").ShallowUnwrapRef<{}> & {
            [x: string]: never;
        } & import("vue").MethodOptions & import("vue").ComponentCustomProperties);
        __isFragment?: never;
        __isTeleport?: never;
        __isSuspense?: never;
    } & import("vue").ComponentOptionsBase<Readonly<{
        [x: number]: string;
    } & {
        length?: number;
        toString?: string;
        toLocaleString?: string;
        concat?: string[];
        join?: string;
        slice?: string[];
        indexOf?: (searchElement: string, fromIndex?: number) => number;
        lastIndexOf?: (searchElement: string, fromIndex?: number) => number;
        every?: {
            <S extends string>(predicate: (value: string, index: number, array: readonly string[]) => value is S, thisArg?: any): this is readonly S[];
            (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any): boolean;
        };
        some?: (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any) => boolean;
        forEach?: (callbackfn: (value: string, index: number, array: readonly string[]) => void, thisArg?: any) => void;
        map?: <U>(callbackfn: (value: string, index: number, array: readonly string[]) => U, thisArg?: any) => U[];
        filter?: {
            <S_1 extends string>(predicate: (value: string, index: number, array: readonly string[]) => value is S_1, thisArg?: any): S_1[];
            (predicate: (value: string, index: number, array: readonly string[]) => unknown, thisArg?: any): string[];
        };
        reduce?: {
            (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string): string;
            (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string, initialValue: string): string;
            <U_1>(callbackfn: (previousValue: U_1, currentValue: string, currentIndex: number, array: readonly string[]) => U_1, initialValue: U_1): U_1;
        };
        reduceRight?: {
            (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string): string;
            (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: readonly string[]) => string, initialValue: string): string;
            <U_2>(callbackfn: (previousValue: U_2, currentValue: string, currentIndex: number, array: readonly string[]) => U_2, initialValue: U_2): U_2;
        };
        find?: {
            <S_2 extends string>(predicate: (this: void, value: string, index: number, obj: readonly string[]) => value is S_2, thisArg?: any): S_2;
            (predicate: (value: string, index: number, obj: readonly string[]) => unknown, thisArg?: any): string;
        };
        findIndex?: (predicate: (value: string, index: number, obj: readonly string[]) => unknown, thisArg?: any) => number;
        entries?: IterableIterator<[number, string]>;
        keys?: IterableIterator<number>;
        values?: IterableIterator<string>;
        includes?: (searchElement: string, fromIndex?: number) => boolean;
        flatMap?: <U_3, This = undefined>(callback: (this: This, value: string, index: number, array: string[]) => U_3 | readonly U_3[], thisArg?: This) => U_3[];
        flat?: unknown[];
    }> | Readonly<{} & {
        [x: string]: unknown;
    }>, unknown, unknown, Record<string, import("@vue/reactivity").ComputedGetter<any> | import("vue").WritableComputedOptions<any>>, import("vue").MethodOptions, import("vue").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, any>, import("vue").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, any>, import("vue").EmitsOptions, string, {
        [x: number]: string;
    } | {}> & import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps & {
        install(app: import("vue").App<any>): void;
    }>;
    handleTabClick: (tab: any, tabName: any, event: any) => void;
    handleTabRemove: (pane: any, ev: any) => void;
    handleTabAdd: () => void;
    currentName: Ref<string>;
    panes: Ref<any[]>;
}, unknown, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, ("tab-click" | "edit" | "tab-remove" | "tab-add" | "input" | "update:modelValue")[], "tab-click" | "edit" | "tab-remove" | "tab-add" | "input" | "update:modelValue", import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps, Readonly<{
    type: string;
    activeName: string;
    closable: boolean;
    addable: boolean;
    modelValue: string;
    editable: boolean;
    tabPosition: string;
    beforeLeave: BeforeLeave;
    stretch: boolean;
} & {}>, {
    type: string;
    activeName: string;
    closable: boolean;
    addable: boolean;
    modelValue: string;
    editable: boolean;
    tabPosition: string;
    beforeLeave: BeforeLeave;
    stretch: boolean;
}>;
export default _default;
